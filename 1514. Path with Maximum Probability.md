Tag: `graph` `priority queue` `BFS`
## Note
1. 學到queue (deque)的用法, 在這題list也可以用, 但list.insert(0, v), list.pop()的記憶體移動都為O(n), deque在頭尾的加入移除都為O(1)
2. 再次複習BFS與DFS的差別, BFS在gragh中會用queue的方式拜訪全部的node(後進後出), DFS會用stack的方式(先進先出). [參考網頁](https://ithelp.ithome.com.tw/articles/10281404?sc=hot)
3. 順便看Heap與stack的差別: 

## Code
    class Solution:
        def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
            
            adj = [[] for _ in range(n)]
            for i in range(len(edges)):
                a, b = edges[i]
                adj[a].append([b, succProb[i]])
                adj[b].append([a, succProb[i]])
    
            node_prob = [0.0] * n
            node_prob[start] = 1.0
            
            queue = deque([start])
    
            while queue:
                curr = queue.popleft()
    
                for node, prob in adj[curr]:
                    new_prob = node_prob[curr] * prob
    
                    if new_prob > node_prob[node]:
                        node_prob[node] = new_prob
                        queue.append(node)
    
            return node_prob[end]

## Complexity analysis
### Time complexity:

### Space complexity:

## Idea
> build a node list [node, prob] that can be loop like: [[[1, 0.5], [2, 0.5]], [[0, 0.5], [1, 0.5]], [[0, 0.5], [1, 0.5]]]
> 
> make a list to store max probibility of each node
> 
> make a queue to search nodes, if prob has been update is larger than max prob, rewrite it and update queue
